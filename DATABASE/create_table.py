#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Cria uma tabela do zero no Postgres (Supabase) com:
- DROP TABLE IF EXISTS ... CASCADE
- Coluna PK incremental (IDENTITY)
- nk_ota_localizer_id como coluna comum (sem UNIQUE)
- Demais colunas conforme /schema da API (TYPE_MAP)

.env necessários:
  PG_DSN=postgresql://user:pass@host:5432/db?sslmode=require
  API_BASE=https://sua.api.com
  API_TOKEN=seu_token
  TABLE_NAME=nome_da_tabela
  SCHEMA_TARGET=core   # opcional
"""

import os
import sys
import requests
from typing import Dict, List
from dotenv import load_dotenv
from psycopg import connect
from psycopg.rows import dict_row

load_dotenv()

PG_DSN       = os.getenv("PG_DSN")
API_BASE     = os.getenv("API_BASE", "").rstrip("/")
API_TOKEN    = os.getenv("API_TOKEN")
TABLE_NAME   = os.getenv("TABLE_NAME")
SCHEMA       = os.getenv("SCHEMA_TARGET", "core")

if not (PG_DSN and API_BASE and API_TOKEN and TABLE_NAME):
    raise SystemExit("Faltam variáveis no .env: PG_DSN, API_BASE, API_TOKEN, TABLE_NAME")

HEADERS = {"x-api-key": API_TOKEN}

TYPE_MAP: Dict[str, str] = {
    "string": "TEXT",
    "float": "DOUBLE PRECISION",
    "decimal": "NUMERIC(12,2)",
    "int": "BIGINT",
    "integer": "BIGINT",
    "bool": "BOOLEAN",
    "boolean": "BOOLEAN",
    "date": "DATE",
    "datetime": "TIMESTAMPTZ",
    "timestamp": "TIMESTAMPTZ",
    "time": "TIME",
}

def quote_ident(name: str) -> str:
    return '"' + str(name).replace('"', '""') + '"'

def fetch_schema_columns() -> List[Dict[str, str]]:
    r = requests.get(f"{API_BASE}/schema", headers=HEADERS, timeout=60)
    r.raise_for_status()
    js = r.json()
    cols = js.get("columns", [])
    if not isinstance(cols, list) or not cols:
        raise ValueError(f"/schema inesperado: {js}")
    # normaliza: cada item deve ter name e type (type opcional)
    return [{"name": c["name"], "type": str(c.get("type", "string")).lower()} for c in cols]

def choose_pk_name(api_cols: List[Dict[str, str]], desired: str = "id") -> str:
    existing = {c["name"].lower() for c in api_cols}
    if desired.lower() in existing:
        return "_id"
    return desired

def build_create_table_sql(api_cols: List[Dict[str, str]]) -> str:
    table_ident = f'{quote_ident(SCHEMA)}.{quote_ident(TABLE_NAME)}'

    # define PK sem colidir com colunas da API
    pk_col = choose_pk_name(api_cols, "id")

    # mapeia colunas da API
    mapped_cols = [f"  {quote_ident(pk_col)} BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY"]
    for c in api_cols:
        pg_t = TYPE_MAP.get(c["type"], "TEXT")
        mapped_cols.append(f"  {quote_ident(c['name'])} {pg_t}")

    # garante nk_ota_localizer_id como coluna comum caso não venha no /schema
    if "nk_ota_localizer_id" not in {c["name"] for c in api_cols}:
        mapped_cols.append(f"  {quote_ident('nk_ota_localizer_id')} TEXT")

    # opcional: carimbo de carga
    mapped_cols.append("  raw_loaded_at TIMESTAMPTZ DEFAULT now()")

    ddl = f"""
DROP TABLE IF EXISTS {table_ident} CASCADE;

CREATE SCHEMA IF NOT EXISTS {quote_ident(SCHEMA)};

CREATE TABLE {table_ident} (
{",\n".join(mapped_cols)}
);
"""
    return ddl

def main():
    print(f"→ Lendo /schema em {API_BASE}/schema …")
    api_cols = fetch_schema_columns()
    print(f"→ {len(api_cols)} colunas vindas da API.")

    ddl = build_create_table_sql(api_cols)
    # print(ddl)  # descomente para inspecionar o SQL

    print("→ Conectando ao Postgres …")
    with connect(PG_DSN, row_factory=dict_row, autocommit=False) as conn:
        with conn.cursor() as cur:
            cur.execute("SET TIME ZONE 'UTC'")
            print("→ Criando tabela do zero …")
            cur.execute(ddl)
        conn.commit()

    print("✅ Tabela criada com sucesso.")
    print(f"   - Schema : {SCHEMA}")
    print(f"   - Tabela : {TABLE_NAME}")
    print(f"   - PK     : {'id' if '\"id\" BIGINT' in ddl else '_id'} (IDENTITY)")
    print("   - nk_ota_localizer_id: coluna comum (sem UNIQUE)")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        import traceback; traceback.print_exc()
        print(f"ERRO: {type(e).__name__} {e}", file=sys.stderr)
        sys.exit(2)
